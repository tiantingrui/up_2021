# 树 

> 玉骢惯识西湖路，骄嘶过、沽酒楼前。 



先来介绍下树的关键特性和重点概念。

+ 树的层次计算规则：根结点所在的那一层记为第一层，其子节点所在的就是第二层，一次类推。
+ 结点和树的“高度”计算规则：叶子结点高度记为1，每向上一层高度就加1，逐层向上累加至目标结点时，所得到的的值就是目标结点的高度。树中结点的最大高度，称为“树的高度”。
+ “度”的概念：一个结点开叉出去多少个子树，被记为结点的“度”。比如我们上图中，根结点的“度”就是3。
+ “叶子结点”：叶子结点就是度为0的结点。在上图中，最后一层的结点的度全部为0，所以这一层的结点都是叶子结点。



### 理解二叉树结构

这里重点介绍**二叉树**。

二叉树是指满足以下要求的树：

+ 它可以没有根结点，作为一颗空树存在
+ 如果它不是空树，那么**必须由根结点、左子树、右子树组成，且左右子树都是二叉树。**如下图：

![img](https://user-gold-cdn.xitu.io/2020/4/6/1714e6b275ab6309?imageslim)

注意，**二叉树不能被简单定义为每个结点的度都是2的树**。普通的树并不会区分左子树和右子树，但在二叉树中，左右子树的位置是严格约定、不能交换的。对应到图上来看，也就意味着 B 和 C、D 和 E、F 和 G 是不能互换的。







### 二叉树的编码实现

在JS中，二叉树使用对象来定义。它的结构分为三块：

+ 数据域
+ 左侧子结点（左子树根节点）的引用
+ 右侧子结点（右子树根结点）的引用



在定义二叉树构造函数时，我们需要把左侧子结点和右侧子结点都预置为空：

```js

function TreeNode(val) {
  this.val = val 
  this.left = this.right = null
}
```

当你需要新建一个二叉树结点时，直接调用构造函数、传入数据域的值就行了：

```js
const node = new TreeNode(1)
```

如此便能得到一个值为 1 的二叉树结点，从结构上来说，它长这样：

![img](https://user-gold-cdn.xitu.io/2020/4/6/1714e6b26ae0d174?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

以这个结点为根结点，我们可以通过给 left/right 赋值拓展其子树信息，延展出一棵二叉树。因此从更加细化的角度来看，一棵二叉树的形态实际是这样的：
![img](https://user-gold-cdn.xitu.io/2020/4/6/1714e6b268b61522?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

现在已经了解了做二叉树面试题所需要的一系列前置知识。接下来我们来搞定二叉树系列里最首当其冲、同时相当热门的考点——二叉树的遍历。



## 递归初相见 - 二叉树递归遍历的三种姿势



### 二叉树的遍历 -- 命题思路解读

以一定的顺序规则，逐个访问二叉树的所有结点，这个过程就是二叉树的遍历。按照顺序规则的不同，遍历方式有以下四种：

- 先序遍历
- 中序遍历
- 后序遍历
- 层次遍历

按照实现方式的不同，遍历方式又可以分为以下两种：

- 递归遍历（先、中、后序遍历）
- 迭代遍历（层次遍历）

层次遍历的考察相对比较孤立，我们会把它放在后续的真题归纳解读环节来讲。这里我们重点要看的是先、中、后序遍历三兄弟——由于同时纠结了二叉树和“递归”两个大热命题点，又不属于“偏难怪”之流，遍历三兄弟一直是前端算法面试官们的心头好，考察热度经久不衰。





### 递归遍历初相见

简单来说，当我们看到一个函数反复调用它自己的时候，递归就发生了。“递归”就意味着“反复”，像咱们之前对二叉树的定义，就可以理解为是一个递归式的定义：

- 它可以没有根结点，作为一棵空树存在
- 如果它不是空树，那么必须由根结点、左子树和右子树组成，**且左右子树都是二叉树**。

这个定义有着这样的内涵：如果我们想要创建一个二叉树结点作为根结点，那么它左侧的子结点和右侧的子结点也都必须符合二叉树结点的定义，这意味着我们要反复地执行“创建一个由数据域、左右子树组成的结点”这个动作，直到数据被分配完为止。

结合这个定义来看，每一棵二叉树都应该由这三部分组成：

![img](https://user-gold-cdn.xitu.io/2020/4/14/17177af5d863f478?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) 对树的遍历，就可以看做是对这三个部分的遍历。这里就引出一个问题：三个部分中，到底先遍历哪个、后遍历哪个呢？我们此处其实可以穷举一下，假如在保证“左子树一定先于右子树遍历”这个前提，那么遍历的可能顺序也不过三种：

- 根结点 -> 左子树 -> 右子树
- 左子树 -> 根结点 -> 右子树
- 左子树 -> 右子树 -> 根结点

上述三个遍历顺序，就分别对应了二叉树的先序遍历、中序遍历和后序遍历规则。

在这三种顺序中，根结点的遍历分别被安排在了首要位置、中间位置和最后位置。
所谓的“先序”、“中序”和“后序”，“先”、“中”、“后”其实就是指根结点的遍历时机。





#### 先序遍历

![img](https://user-gold-cdn.xitu.io/2020/4/6/1714ec42acc57e04?imageslim)

```js
const root = {
  val: "A",
  left: {
    val: "B",
    left: {
      val: "D"
    },
    right: {
      val: "E"
    }
  },
  right: {
    val: "C",
    right: {
      val: "F"
    }
  }
}
```



##### 递归函数的编写要点

编写一个递归函数之前，大家首先要明确两样东西：

- 递归式
- 递归边界

递归式，它指的是你每一次重复的内容是什么。在这里，我们要做先序遍历，那么每一次重复的其实就是 `根结点 -> 左子树 -> 右子树` 这个旅行路线。

递归边界，它指的是**你什么时候停下来**。
在遍历的场景下，当我们发现遍历的目标树为空的时候，就意味着旅途已达终点、需要画上句号了。这个“画句号”的方式，在编码实现里对应着一个 return 语句——这就是二叉树遍历的递归边界。



##### 第一个递归遍历函数

先序遍历的编码实现

```js
// 所有遍历函数的入参都是树的根结点对象
function preorder(root) {
    // 递归边界，root 为空
    if(!root) {
        return 
    }
     
    // 输出当前遍历的结点值
    console.log('当前遍历的结点值是：', root.val)  
    // 递归遍历左子树 
    preorder(root.left)  
    // 递归遍历右子树  
    preorder(root.right)
}
```







#### 中序遍历

理解了先序遍历的过程，中序遍历就不是什么难题。唯一的区别只是把遍历顺序调换了左子树 -> 根结点 -> 右子树：

![img](https://user-gold-cdn.xitu.io/2020/4/6/1714f098b2bd1f9a?imageslim)



递归边界照旧，唯一发生改变的是递归式里调用递归函数的顺序——左子树的访问会优先于根结点。我们参考先序遍历的分析思路，来写中序遍历的代码：

```js
// 所有遍历函数的入参都是树的根结点对象
function inorder(root) {
    // 递归边界，root 为空
    if(!root) {
        return 
    }
     
    // 递归遍历左子树 
    inorder(root.left)  
    // 输出当前遍历的结点值
    console.log('当前遍历的结点值是：', root.val)  
    // 递归遍历右子树  
    inorder(root.right)
}
```





#### 后序遍历

在后序遍历中，我们先访问左子树，再访问右子树，最后访问根结点：

![img](https://user-gold-cdn.xitu.io/2020/4/6/1714efce7db2cdff?imageslim)



 在编码实现的时候，递归边界照旧，唯一发生改变的仍然是是递归式里调用递归函数的顺序：



```js
function postorder(root) {
    // 递归边界，root 为空
    if(!root) {
        return 
    }
     
    // 递归遍历左子树 
    postorder(root.left)  
    // 递归遍历右子树  
    postorder(root.right)
    // 输出当前遍历的结点值
    console.log('当前遍历的结点值是：', root.val)  
}
```





## 二叉树实战

有以下三个命题方向需要大家重点掌握： 

- 迭代法实现二叉树的先、中、后序遍历 
- 二叉树层序遍历的衍生问题
- 翻转二叉树 

这三个方向对应的考题都比较经典。与此同时，解决这些问题涉及到的思路和编码细节，也会成为各位日后解决更加复杂的问题的基石





### "遍历三兄弟"的迭代实现

通过使用递归，我们可以把原本复杂的东西，拆解成非常简单的、符合人类惯用脑回路的逻辑。



#### 从先序遍历说起

> 题目：给定一个二叉树，返回它的前序（先序）遍历序列

示例：

输入: [1,null,2,3]

```
1   
 \   
  2   
 /  
3 
```

输出： [1, 2, 3]

进阶: 递归算法很简单，你可以通过迭代算法完成吗？

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
const preorderTraversal = function(root) {
  // 定义结果数组
  const res = []  
  // 处理边界条件
  if(!root) {
      return res
  }
  // 初始化栈结构
  const stack = [] 
  // 首先将根结点入栈
  stack.push(root)  
  // 若栈不为空，则重复出栈、入栈操作
  while(stack.length) {
      // 将栈顶结点记为当前结点
      const cur = stack.pop() 
      // 当前结点就是当前子树的根结点，把这个结点放在结果数组的尾部
      res.push(cur.val)
      // 若当前子树根结点有右孩子，则将右孩子入栈
      if(cur.right) {
          stack.push(cur.right)
      }
      // 若当前子树根结点有左孩子，则将左孩子入栈
      if(cur.left) {
          stack.push(cur.left)
      }
  }
  // 返回结果数组
  return res
};
```















