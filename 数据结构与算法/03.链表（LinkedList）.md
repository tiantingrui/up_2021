# 链表（LinkedList）

### 什么是链表？

链表和数组相似，它们都是有序的列表、都是线性结构（有且仅有一个前驱、有且仅有一个后继）。

不同点在于，链表中，数据单位的名称叫做“结点”，而结点和结点的分布，在内存中刻意是**离散**的。

在链表中，每一个结点的结构都包括了两部分的内容：数据域和指针域。JS中的链表，是以嵌套的对象的形式来实现的：

```js
{
  // 数据域
  val: 1,
  // 指针域, 指向下一个结点
  next: {
    val: 2,
    next: ...
  }
}
```

数据域存储的是当前结点所存储的数据值，而指针域则代表下一个结点（后继结点）的引用。 有了 next 指针来记录后继结点的引用，每一个结点至少都能知道自己后面的同学是哪位了。



### 链表结点的创建

创建链表结点，我们需要一个构造函数：

```js
function ListNode(val) {
  this.val = val
  this.next = null
}
```

在使用构造函数创建结点时，传入 val （数据域对应的值内容）、指定 next （下一个链表结点）即可：

```js
const node = new ListNode(1)
node.next = new ListNode(2)
```

以上，就创建出了一个数据域值为1，next 结点数据域值为2的链表结点.





### 链表元素的添加

结合前面的学习，我们已经知道，链表的结点间关系是通过 next 指针来维系的。因此，链表元素的添加和删除操作，本质上都是在围绕 next 指针做文章。

假如有链表中两个结点 1，2

情景1：往链表最后面插入 3

这个很简单，直接把node2的next指向3即可。

```js
const target = node2
node2.next = new ListNode(3)
```

情景2：（**重点**）往1和2之间插入3

要想完成这个动作，我们需要变更的是**前驱结点**和**目标结点**的 next 指针指向

```js
const node3 = new ListNode(3)
node3.next = node1.next
node1.next = node3
```



### 链表元素的删除

链表元素的删除也是非常高频的操作。延续我们前面的思路，仍然把重心放在对 next 指针的调整上。我们思考一下：如何把刚刚添加进来的 node3 从现在的链表里删掉？
注意，删除的标准是：在链表的遍历过程中，无法再遍历到某个结点的存在。按照这个标准，要想遍历不到 node3，我们直接让它的前驱结点 node1 的 next 指针跳过它、指向 node3 的后继即可。

如此一来，node3 就成为了一个完全不可抵达的结点了，它会被 JS 的垃圾回收器自动回收掉。这个过程用代码表述如下：

```js
node1.next = node3.next
```

这里给大家提个醒：在涉及链表删除操作的题目中，重点不是定位目标结点，而是**定位目标结点的前驱结点**。做题时，完全可以只使用一个指针（引用），这个指针用来定位目标结点的前驱结点。比如说咱们这个题里，其实只要能拿到 node1 就行了。



### 链表和数组的辨析

在大多数的计算机语言中，数组都对应着一段连续的内存。如果我们想要在任意位置删除一个元素，那么该位置往后的所有元素，都需要往前挪一个位置；相应地，如果要在任意位置新增一个元素，那么该位置往后的所有元素也都要往后挪一个位置。
**我们假设数组的长度是 n，那么因增加/删除操作导致需要移动的元素数量，就会随着数组长度 n 的增大而增大，呈一个线性关系。所以说数组增加/删除操作对应的复杂度就是 O(n)**。

**但 JS 中不一定是。**

JS比较特别。如果我们在一个数组中只定义了一种类型的元素，比如

```js
const arr = [1, 2, 3, 4]
```

 它是一个纯数字数组，那么对应的确实是连续内存。

但如果我们定义了**不同类型的元素**：

```js
const arr = ['terry', 1, {a: 1}]
```

它对应的就是一段**非连续的内存**。此时，JS数组不再具有数组的特征，其**底层使用哈希映射分配内存空间，是由对象链表来实现的。**

在这里要知道 **JS数组未必是真正的数组**即可

何谓“真正的数组”？在各大教材（包括百科词条）对数组的定义中，都有一个“存储在连续的内存空间里”这样的必要条件。因此在本文中，我们描述的“数组”就是符合这个定义的数组。面试时，若考到数组和链表的辨析，大家也沿着这个思路往下说，是没有问题的。如果能够说出 JS 数组和常规数组的不同，那就是锦上添花了。





### 单链表与双链表

单链表：链表中的每个元素实际上是一个单独的对象，而所有对象都通过每个元素中的引用字段链接在一起。

双链表：与单链表不同的是，双链表的每个节点中都包含有两个引用字段。



### 链表的优缺点

**优点**

+ 链表能灵活地分配内存空间
+ 能在 O(1) 时间内**删除或者添加**元素，前提是该元素的前一个元素已知，当然也取决于是单链表还是双链表，在双链表中，如果已知该元素的后一个元素，同样可以在O(1)时间内删除或者添加该元素。

**缺点**

+ 不像数组能通过下标迅速读取元素，每次都要从链表头开始一个一个读取；
+ **查询**第 k 个元素需要 O(k) 时间。



### 应用场景

如果要解决的问题里面需要很多快速查询，链表可能并不适合；如果遇到的问题中，数据的元素个数不确定，而且需要经常进行数据的添加和删除，那么链表会比较合适。而如果数据元素大小确定，删除插入的操作并不多，那么数组可能更适合。



### 经典题目分类

+ 链表的处理：合并、删除等（删除操作画个记号，重点中的重点）
+ 链表的反转及其衍生题目
+ 链表成环问题及其衍生题目





### 经典解法

链表是实现很多复杂结构的基础，经典解法如下。

1. **利用快慢指针**（有时候需要用到三个指针）

   典型题目例如：链表的翻转，寻找倒数第K个元素，寻找链表中间位置的元素，判断链表是否有环等。

2. **构建一个虚假的链表头**

   一般用在要返回新的链表的题目中，比如，给定两个排好序的链表，要求将它们整合在一起并排好序。又比如，将一个链表中的奇数和偶数按照原定的顺序分开后重新组合成一个新的链表，链表的头一半是奇数，后一半是偶数。

   在这类问题里，如果不用一个虚假的链表头，那么在创建新链表的第一个元素时，我们都得要判断一下链表的头指针是否为空，也就是要多写一条 if else 语句。比较简洁的写法是创建一个空的链表头，直接往其后面添加元素即可，最后返回这个空的链表头的下一个节点即可。



#### leetcode 25 例题分析

> 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

说明：

+ 你的算法只能使用常数的额外空间
+ 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换

示例：

给定这个链表：1->2->3->4->5

当 k=2 时，应当返回：2->1->4->3->5

当 k=3 时，应当返回：3->2->1->4->5



**结题思路**

这道题考察了两个知识点：

1. 对链表翻转算法是否熟悉
2. 对递归算法的理解是否清晰

在翻转链表的时候，可以借助三个指针：prev、curr、next，分别代表前一个节点、当前节点和下一个节点，实现过程如下所示。

![img](https://s0.lgstatic.com/i/image2/M01/90/E9/CgotOV2IRJ2AYlnUACToKJcAldQ867.gif)



1. 将 curr 指向的下一节点保存到 next 指针；
2. curr 指向 prev，一起前进一步；
3. 重复之前步骤，直到 k 个元素翻转完毕；
4. 当完成了局部的翻转后，prev 就是最终的新的链表头，curr 指向了下一个要被处理的局部，而原来的头指针 head 成为了链表的尾巴。

注意：这道题是“LeetCode 第 24 题，两个一组翻转链表“的扩展，即当 k 等于 2 时，第 25 题就变成了第 24 题。





#### 链表的合并

> 题目：将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有结点组成的

栗子：

输入：1->2->4, 1->3->4 输出：1->1->2->3->4->4

```js
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
const mergeTwoLists = function(l1, l2) {
  // 定义头结点，确保链表可以被访问到
  let head = new ListNode()
  // cur 这里就是咱们那根“针”
  let cur = head
  // “针”开始在 l1 和 l2 间穿梭了
  while(l1 && l2) {
      // 如果 l1 的结点值较小
      if(l1.val<=l2.val) {
          // 先串起 l1 的结点
          cur.next = l1
          // l1 指针向前一步
          l1 = l1.next
      } else {
          // l2 较小时，串起 l2 结点
          cur.next = l2
          // l2 向前一步
          l2 = l2.next
      }
      
      // “针”在串起一个结点后，也会往前一步
      cur = cur.next 

  }
  
  // 处理链表不等长的情况
  cur.next = l1!==null?l1:l2
  // 返回起始结点
  return head.next
};
```



#### 链表结点的删除

> 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

示例：

输入: 1->1->2
输出: 1->2

输入: 1->1->2->3->3
输出: 1->2->3

**思路分析**

判断两个元素是否重复，由于此处是已排序的链表，我们直接判断前后两个元素值是否相等即可。

```js
const deleteDuplicates = (head) => {
    // 设定cur 指针，初始位置为链表的第一个结点
    const cur = head
    // 遍历链表
    while (cur !== null && cur.next !== null) {
        // 当前结点和下一个结点值相等（重复）就删除
        if (cur.val = cur.next.val) {
            cur.next = cur.next.next
        } else {
            // 若不相等就接着遍历
            cur = cur.next
        }
    }

    return head
}
```

拿这道题来说，既能考察你链表的遍历（while循环），又能考察你链表的 CRUD 中最热门的删除操作，候选人做这道题的情况，一定程度上可以反馈其基本功的扎实度。做对了是正常，如果做不对，那么在算法和数据结构这个考察环节，你的处境就有点危险了。



#### 删除问题的延伸 -- dummy结点登场

> 给定一个排序链表，删除所有含有重复数字的结点，只保留原始链表中 没有重复出现的数字。

示例：

输入: 1->2->3->3->4->4->5
输出: 1->2->5

输入: 1->1->2->3->3
输出: 2->3

**思路分析**

我们先来分析一下这道题和上道题有什么异同哈：相同的地方比较明显，都是删除重复元素。不同的地方在于，楼上我们删到没有重复元素就行了，可以留个“独苗”；但现在，题干要求我们只要一个元素发生了重复，就要把它彻底从链表中干掉，一个不留。

这带来了一个什么问题呢？我们回顾一下前面咱们是怎么做删除的：在遍历的过程中判断当前结点和后继结点之间是否存在值相等的情况，若有，直接对后继结点进行删除：

但是现在，咱们要做的事情变成了把前驱和后继一起删掉，

如果继续沿用刚才的思路，我们会发现完全走不通。因为我们的 cur 指针就是从图中第一个结点出发开始遍历的，无法定位到第一个结点的前驱结点，删除便无法完成。

其实在链表题中，经常会遇到这样的问题：链表的第一个结点，因为没有前驱结点，导致我们面对它无从下手。这时我们就可以用一个 `dummy` 结点来解决这个问题。
所谓 dummy 结点，就是咱们人为制造出来的第一个结点的前驱结点，这样链表中所有的结点都能确保有一个前驱结点，也就都能够用同样的逻辑来处理了。
dummy 结点能够帮助我们降低链表处理过程的复杂度，处理链表时，不设 dummy 结点思路可能会打不开；设了 dummy 结点的话，就算不一定用得上，也不会出错。



注意：由于重复的结点可能不止一个两个，我们这里需要用一个 while 循环来反复地进行重复结点的判断和删除操作。



```js
const deleteDuplicatesExtend = (head) => {
    // 只有 0 个 或者 1个结点的情况下，直接返回 head
    if (!head || !head.next) {
        return head
    }
    // 创建一个假节点
    let dummy = new ListNode()
    // dummy 永远指向头结点
    dummy.next = head
    // cur 从 dummy 开始遍历
    let cur = dummy
    // 当cur的后面有至少两个结点时
    while(cur.next && cur.next.next) {
        // 对 cur 后面的两个结点进行比较
        if (cur.next.val === cur.next.next.val) {
            // 若值重复，先记下来这个值，看看后面还有没有与这个值重复的结点
            let val = cur.next.val
            // 反复排查后面的元素是否多次重复此值
            while (cur.next && cur.next.val === val) {
                // 如存在，删除即可
                cur.next = cur.next.next
            }
        } else {
            // 若不重复，接着遍历
            cur = cur.next
        }
    }
    // 返回列表的起始结点
    return dummy.next
}
```



## 剑指offer

> 输入一个链表的头结点，从尾到头反过来打印出每个结点的值。(P58)

