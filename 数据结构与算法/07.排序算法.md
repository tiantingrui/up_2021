# 排序算法



以面试为导向来看，需要重点掌握的排序算法，主要是以下5种：

+ 基础排序算法
  1. 冒泡排序
  2. 选择排序
  3. 插入排序
+ 进阶排序算法
  1. 归并排序
  2. 快速排序



## 冒泡排序

#### 基本思路分析

冒泡排序的过程，就是从第一个元素开始，**重复比较相邻的两个项**，若第一项比第二项更大，则交换两者的位置；反之不动。
每一轮操作，都会将这一轮中最大的元素放置到数组的末尾。假如数组的长度是 `n`，那么当我们重复完 `n` 轮的时候，整个数组就有序了。

<img src="//www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif">



基础版的冒泡思路实现

```js
function bubbleSort(arr) {
  const len = arr.length
  for (let i = 0; i < len; i++) {
    for (let j = 0; j < len - 1; j ++) {
      if (arr[j] > arr[j + 1]) {
        // 如果当前数值大于后一个数值，则调换顺序
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
      }
    }
  }
  return arr
}
```



#### 基础版的冒泡思路改进

在上面，你会发现其实我们 第 i 次 都会将最大的数字 排在 第`len - i` 上，意味着之后不需要再去比较 `len - i`之后的数值， 在这里就值得我们去改进。

```js
function betterBubbleSort(arr) {
  const len = arr.length
  for (let i = 0; i < len; i ++) {
    // 注意这里我们直接避免了重复去比较 len - i 之后已经排好序的数值
    for (let j = 0; j < len - i - 1; j ++) {
      if (arr[j] > arr[j + 1]) {
         // 如果当前数值大于后一个数值，则调换顺序
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
      }
    }
  }
}
```



#### 最优解法

在这里大家想一下，如果是一个已经排好序的数组，那么我们还需要进行两层遍历么，是不是可以达到O(n)的效率。

这里就针对于这种情况作出最优的解法

```js
function bestBubbleSort(arr) {
  const len = arr.length
  for (let i = 0; i < len; i++) {
    // 注意这里我们加了一个标志位
    let flag = false
    for (let j = 0; j < len - i - 1; j ++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
        // 只要有一次交换， 就修改标志位
        flag = true
      }
    }
    // 如果一次都没交换，证明是有序数组了，直接返回
    if (!flag) return arr
  }
  
  return arr
}
```

标志位可以帮助我们在第一次冒泡的时候就定位到数组是否完全有序，进而节省掉不必要的判断逻辑，将最好情况下的时间复杂度定向优化为 `O(n)`。



**编码复盘 -- 冒泡排序的时间复杂度**

我们分最好、最坏和平均来看：

- **最好时间复杂度**：它对应的是数组本身有序这种情况。在这种情况下，我们只需要作比较（n-1 次），而不需要做交换。时间复杂度为 **O(n)**
- **最坏时间复杂度**： 它对应的是数组完全逆序这种情况。在这种情况下，每一轮内层循环都要执行，重复的总次数是 n(n-1)/2 次，因此时间复杂度是 **O(n^2)**
- **平均时间复杂度**：这个东西比较难搞，它涉及到一些概率论的知识。实际面试的时候也不会有面试官摁着你让你算这个，这里记住平均时间复杂度是 **O(n^2)** 即可。





## 选择排序

#### 思路分析

选择排序的关键字是“**最小值**”：循环遍历数组，每次都找出当前范围内的最小值，把它放在当前范围的头部；然后缩小排序范围，继续重复以上操作，直至数组完全有序为止。

![img](https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif)



编码实现：

```js
function selectSort(arr) {
  const len = arr.length
  for (let i = 0; i < len; i++) {
    let minIndex = i // 注意这里记录最小值的下标，下标！！！先默认第一个为最小值，如果不是就换掉
    // i、j分别定义当前区间的上下界，i是左边界，j是右边界
    for (let j = i; j < len; j++) {
      // 若 j 处的数据项比当前最小值还要小，则更新最小值索引为 j
      if (arr[j] < arr[i]) {
        minIndex = j
      }
    }
    // 如果 minIndex 对应元素不是目前的头部元素，则交换两者
    if (minIndex !== i) {
      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]
    }
  }
  return arr
}
```

#### 编码复盘——选择排序的时间复杂度

在时间复杂度这方面，选择排序没有那么多弯弯绕绕：最好情况也好，最坏情况也罢，两者之间的区别仅仅在于元素交换的次数不同，**但都是要走内层循环作比较的**。因此选择排序的三个时间复杂度都对应两层循环消耗的时间量级： O(n^2)。



## 插入排序

#### 思路分析

插入排序的核心思想是”找到元素在它前面那个序列中的正确位置“。

正确来说，插入排序所有的操作都基于一个这样的前提：当前元素的序列是有序的。基于这个前提，从后往前去寻找当前元素在前面那个序列里的正确位置。

插入排序的几个关键点：

+ 当前元素前面的那个序列是有序的
+ ”正确的位置“如何定义 -- 所有在当前元素前面的数都不大于它，所有在当前元素后的数都不小于它
+ 在有序序列里定位元素位置的时候，是从后往前定位的。只要发现一个比当前元素大的值，就需要为当前元素腾出一个新的坑位。



#### 编码实现

```js
// 插入排序
function insertSort(arr) {
    const len = arr.length
    // 用temp 来代表当前需要插入的元素
    let temp
    // i 用于标识每次被插入的元素的索引
    for (let i = 1; i < len; i++) {
        // j 用于帮助 temp 寻找自己应该有的定位
        let j = i
        temp = arr[i]
        // 判断 j 前一个元素是否比 temp 大
        while (j > 0 && arr[j - 1] > temp) {
            // 如果是，则将 j 前面的一个元素后移一位， 为temp 让出位置
            arr[j] = arr[j - 1]
            j--
        }
        // 循环让位，最后得到的 j 就是 temp 的正确索引
        arr[j] = temp
    }
    return arr
}
```



#### 复盘  -  插入排序的时间复杂度

- **最好时间复杂度**：它对应的数组本身就有序这种情况。此时内层循环只走一次，整体复杂度取决于外层循环，时间复杂度就是一层循环对应的 **O(n)**。
- **最坏时间复杂度**：它对应的是数组完全逆序这种情况。此时内层循环每次都要移动有序序列里的所有元素，因此时间复杂度对应的就是两层循环的 O(n^2)
- **平均时间复杂度**：O(n^2)



> 基础排序算法，普遍符合两个特征
>
> 1. 易于理解，上手迅速
> 2. 时间效率差

















































