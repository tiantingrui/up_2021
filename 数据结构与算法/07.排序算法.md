# 排序算法



以面试为导向来看，需要重点掌握的排序算法，主要是以下5种：

+ 基础排序算法
  1. 冒泡排序
  2. 选择排序
  3. 插入排序
+ 进阶排序算法
  1. 归并排序
  2. 快速排序



## 冒泡排序

#### 基本思路分析

冒泡排序的过程，就是从第一个元素开始，**重复比较相邻的两个项**，若第一项比第二项更大，则交换两者的位置；反之不动。
每一轮操作，都会将这一轮中最大的元素放置到数组的末尾。假如数组的长度是 `n`，那么当我们重复完 `n` 轮的时候，整个数组就有序了。

<img src="//www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif">



基础版的冒泡思路实现

```js
function bubbleSort(arr) {
  const len = arr.length
  for (let i = 0; i < len; i++) {
    for (let j = 0; j < len - 1; j ++) {
      if (arr[j] > arr[j + 1]) {
        // 如果当前数值大于后一个数值，则调换顺序
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
      }
    }
  }
  return arr
}
```



#### 基础版的冒泡思路改进

在上面，你会发现其实我们 第 i 次 都会将最大的数字 排在 第`len - i` 上，意味着之后不需要再去比较 `len - i`之后的数值， 在这里就值得我们去改进。

```js
function betterBubbleSort(arr) {
  const len = arr.length
  for (let i = 0; i < len; i ++) {
    // 注意这里我们直接避免了重复去比较 len - i 之后已经排好序的数值
    for (let j = 0; j < len - i - 1; j ++) {
      if (arr[j] > arr[j + 1]) {
         // 如果当前数值大于后一个数值，则调换顺序
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
      }
    }
  }
}
```



#### 最优解法

在这里大家想一下，如果是一个已经排好序的数组，那么我们还需要进行两层遍历么，是不是可以达到O(n)的效率。

这里就针对于这种情况作出最优的解法

```js
function bestBubbleSort(arr) {
  const len = arr.length
  for (let i = 0; i < len; i++) {
    // 注意这里我们加了一个标志位
    let flag = false
    for (let j = 0; j < len - i - 1; j ++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
        // 只要有一次交换， 就修改标志位
        flag = true
      }
    }
    // 如果一次都没交换，证明是有序数组了，直接返回
    if (!flag) return arr
  }
  
  return arr
}
```

标志位可以帮助我们在第一次冒泡的时候就定位到数组是否完全有序，进而节省掉不必要的判断逻辑，将最好情况下的时间复杂度定向优化为 `O(n)`。



**编码复盘 -- 冒泡排序的时间复杂度**

我们分最好、最坏和平均来看：

- **最好时间复杂度**：它对应的是数组本身有序这种情况。在这种情况下，我们只需要作比较（n-1 次），而不需要做交换。时间复杂度为 **O(n)**
- **最坏时间复杂度**： 它对应的是数组完全逆序这种情况。在这种情况下，每一轮内层循环都要执行，重复的总次数是 n(n-1)/2 次，因此时间复杂度是 **O(n^2)**
- **平均时间复杂度**：这个东西比较难搞，它涉及到一些概率论的知识。实际面试的时候也不会有面试官摁着你让你算这个，这里记住平均时间复杂度是 **O(n^2)** 即可。





## 选择排序

#### 思路分析

选择排序的关键字是“**最小值**”：循环遍历数组，每次都找出当前范围内的最小值，把它放在当前范围的头部；然后缩小排序范围，继续重复以上操作，直至数组完全有序为止。

![img](https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif)



编码实现：

```js
function selectSort(arr) {
  const len = arr.length
  for (let i = 0; i < len; i++) {
    let minIndex = i // 注意这里记录最小值的下标，下标！！！先默认第一个为最小值，如果不是就换掉
    // i、j分别定义当前区间的上下界，i是左边界，j是右边界
    for (let j = i; j < len; j++) {
      // 若 j 处的数据项比当前最小值还要小，则更新最小值索引为 j
      if (arr[j] < arr[i]) {
        minIndex = j
      }
    }
    // 如果 minIndex 对应元素不是目前的头部元素，则交换两者
    if (minIndex !== i) {
      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]
    }
  }
  return arr
}
```

#### 编码复盘——选择排序的时间复杂度

在时间复杂度这方面，选择排序没有那么多弯弯绕绕：最好情况也好，最坏情况也罢，两者之间的区别仅仅在于元素交换的次数不同，**但都是要走内层循环作比较的**。因此选择排序的三个时间复杂度都对应两层循环消耗的时间量级： O(n^2)。



## 插入排序

#### 思路分析

插入排序的核心思想是”找到元素在它前面那个序列中的正确位置“。

正确来说，插入排序所有的操作都基于一个这样的前提：当前元素的序列是有序的。基于这个前提，从后往前去寻找当前元素在前面那个序列里的正确位置。

插入排序的几个关键点：

+ 当前元素前面的那个序列是有序的
+ ”正确的位置“如何定义 -- 所有在当前元素前面的数都不大于它，所有在当前元素后的数都不小于它
+ 在有序序列里定位元素位置的时候，是从后往前定位的。只要发现一个比当前元素大的值，就需要为当前元素腾出一个新的坑位。



#### 编码实现

```js
// 插入排序
function insertSort(arr) {
    const len = arr.length
    // 用temp 来代表当前需要插入的元素
    let temp
    // i 用于标识每次被插入的元素的索引
    for (let i = 1; i < len; i++) {
        // j 用于帮助 temp 寻找自己应该有的定位
        let j = i
        temp = arr[i]
        // 判断 j 前一个元素是否比 temp 大
        while (j > 0 && arr[j - 1] > temp) {
            // 如果是，则将 j 前面的一个元素后移一位， 为temp 让出位置
            arr[j] = arr[j - 1]
            j--
        }
        // 循环让位，最后得到的 j 就是 temp 的正确索引
        arr[j] = temp
    }
    return arr
}
```



#### 复盘  -  插入排序的时间复杂度

- **最好时间复杂度**：它对应的数组本身就有序这种情况。此时内层循环只走一次，整体复杂度取决于外层循环，时间复杂度就是一层循环对应的 **O(n)**。
- **最坏时间复杂度**：它对应的是数组完全逆序这种情况。此时内层循环每次都要移动有序序列里的所有元素，因此时间复杂度对应的就是两层循环的 O(n^2)
- **平均时间复杂度**：O(n^2)



> 基础排序算法，普遍符合两个特征
>
> 1. 易于理解，上手迅速
> 2. 时间效率差





### 认识 ”分治“思想

快速排序和归并排序都会用到 ”分治“思想，我们先来看看什么是分治思想。

**“分治”，分而治之。其思想就是将一个大问题分解为若干个子问题，针对子问题分别求解后，再将子问题的解整合为大问题的解**。

利用分治思想解决问题，我们一般分三步走：

+ 分解子问题

+ 求解每个子问题
+ 合并子问题的解，得出大问题的解

下面我们来看一看分治思想是如何帮助我们提升排序算法效率的。





## 归并排序

#### 思路分析

归并排序是对分治思想的典型应用，它按照如下的思路对分治思想“三步走”的框架进行了填充：

- **分解子问题**：将需要被排序的数组从中间分割为两半，然后再将分割出来的每个子数组各分割为两半，重复以上操作，直到单个子数组只有一个元素为止。
- **求解每个子问题**：从粒度最小的子数组开始，两两合并、确保每次合并出来的数组都是有序的。（这里的“子问题”指的就是对每个子数组进行排序）。
- **合并子问题的解，得出大问题的解**：当数组被合并至原有的规模时，就得到了一个完全排序的数组



### 真实排序过程演示

下面我们基于归并排序的思路，尝试对以下数组进行排序：

```js
[8, 7, 6, 5, 4, 3, 2, 1]
```

**首先重复地分割数组，整个分割过程如下**：
首次分割，将数组整个对半分：

```js
[8, 7, 6, 5,| 4, 3, 2, 1]
```

二次分割，将分割出的左右两个子数组各自对半分：

```js
[8, 7,| 6, 5,| 4, 3,| 2, 1]
```

三次分割，四个子数组各自对半分后，每个子数组内都只有一个元素了：

```js
[8,| 7,| 6,| 5,| 4,| 3,| 2,| 1]
```

**接下来开始尝试解决每个子问题**。将规模为1的子数组两两合并为规模为2的子数组，合并时确保有序，我们会得到这样的结果：

```js
[7, 8,| 5, 6,| 3, 4,| 1, 2]
```

继续将规模为2的按照有序原则合并为规模为4的子数组：

```js
[5, 6, 7, 8,| 1, 2, 3, 4]  
```

最后将规模为4的子数组合并为规模为8的数组：

```js
[1, 2, 3, 4, 5, 6, 7, 8]  
```

整个数组就完全有序了。



通过上面的讲解，我们可以总结出归并排序中的两个主要动作：

- 分割
- 合并

这两个动作是紧密关联的，分割是将大数组反复分解为一个一个的原子项，合并是将原子项反复地组装回原有的大数组。整个过程符合两个特征：

1. 重复（令人想到递归或迭代）
2. 有去有回（令人想到回溯，进而明确递归这条路）

因此，归并排序在实现上依托的就是递归思想。
除此之外，这里还涉及到另一个小小的知识点——**两个有序数组的合并**。合并有序数组，涉及到双指针法。



```js

function mergeArr(arr1, arr2) {
    // 初始化两个指针，分别指向arr1 和 arr2
    let i = 0, j =0
    // 初始化结果数组
    const res = []
    
    const len1 = arr1.length
    const len2 = arr2.length
    // 合并两个子数组
    while(i < len1 && j < len2) {
        if (arr1[i] < arr2[j]) {
            res.push(arr1[i])
            i++
        } else {
            res.push(arr2[j])
            j++ 
        }
    }
    // 若其中一个子数组首先被合并完全，则直接拼接另一个子数组的剩余部分
    if (i < len1) {
        return res.concat(arr1.slice(i))
    } else {
        return res.concat(arr2.slice(j))
    }
}
```



























